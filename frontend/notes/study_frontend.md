# [정형화된 기록 양식 예시]

## [기능/이슈명]

- (간단한 기능/이슈 요약)

### 1. 동작 목적/배경

- (왜 이 기능/이슈가 필요한지)

### 2. 동작 구조/원리

- (핵심 동작 구조, 상태, 흐름 등)

### 3. 세부 동작 과정

1. (step1)
2. (step2) ...

### 4. 고려사항/특이사항

- (예외, UX, 기술적 한계 등)

### 5. 결론/의견

- (최종 결론, 남길 의견 등)

---

# FCM(푸시 알림) 설정 및 동작 원리 정리

## 1. 전체 동작 구조

- **FCM 권한 및 토큰 처리**

  - 사용자가 앱에 진입하거나 로그인/새로고침 시 FCM 권한을 확인
  - 권한이 없으면 요청, 허용 시 FCM 토큰 발급 및 서버 저장
  - 권한 거부 시 안내만 띄움
  - 권한 허용 시에만 FCM 토큰을 서버에 저장

- **API 에러 처리**

  - API 에러 발생 시 FCM(브라우저 알림)으로 에러 메시지 전송

- **FCM 토큰 저장**
  - FCM 토큰을 서버에 저장하는 별도 API 활용

## 2. 문제점 및 개선 필요성

- 사용자가 FCM 권한을 허용하지 않았는데도 알림이 동작하거나, 알림 설정이 제대로
  제어되지 않는 문제 발생 가능
- 사용자가 명확하게 "알림을 켜겠다"고 선택한 경우에만 FCM 토큰을 발급/저장해야함

## 3. 개선된 동작 방식 및 UX

- **설정 페이지의 알림 스위치(SwitchToggle)**

  - 사용자가 직접 알림을 켜고 끌 수 있도록 함
  - 스위치를 ON하면 FCM 권한 요청 및 토큰 저장
  - 한 번 ON하면 OFF로 변경 불가(비활성화)

- **현실적인 웹 FCM 동작**
  - 브라우저에서 알림 권한이 허용되어야만 푸시 알림이 동작
  - 권한이 거부된 경우 JS에서 알림을 켤 수 없음
  - 권한이 허용된 경우에만 토큰을 서버에 등록/삭제하여 알림 수신 제어

## 4. 실제 구현 방법

### (1) 상태 관리

- `notificationsEnabled`: 알림 설정 여부
- `notificationLocked`: 한 번 ON되면 true, 스위치 비활성화

### (2) 스위치 ON 시

- FCM 권한 요청 및 토큰 저장 시도
- 성공 시 `notificationsEnabled`, `notificationLocked` 모두 true
- 실패(권한 거부 등) 시 안내 메시지

### (3) 스위치 OFF 불가

- `notificationLocked`가 true면 스위치 비활성화(disabled)

### (4) UI/UX

- 스위치를 켜면 권한이 없을 경우 권한 요청
- 스위치를 끄는 것은 불가(비활성화)
- 안내 메시지는 모달/알림 등으로 제공

## 5. 동작 과정 예시

1. 사용자가 앱에 진입
2. FCM 토큰이 없고, "다신 안보기"도 체크 안 되어 있으면 안내 모달 표시
3. 사용자가 알림 스위치 ON
   - 브라우저 권한 확인
   - 권한 없음 → 권한 요청 → 허용 시 토큰 저장
   - 권한 거부 → 안내 메시지
   - 권한 허용 → 토큰 저장, 스위치 비활성화
4. 사용자가 "다신 안보기"를 누르면 localStorage에 기록되어 안내 모달이 다시 뜨지
   않음

## 6. 결론 및 이유

- SwitchToggle로 알림을 켜는 것은 서버에 FCM 토큰을 등록하는 것
- 브라우저 권한이 거부된 경우에는 JS에서 알림을 켤 수 없음
- "다신 안보기"는 localStorage에 기록하여 UX 개선

---

## [FCM 알림 설정/토글 UX 개선]

- (설정 페이지에서 알림 스위치로 FCM 알림을 직접 켜고, 한 번 켜면 끌 수 없게 UX
  를 개선)

### 1. 동작 목적/배경

- 사용자가 명확하게 "알림을 켜겠다"고 선택한 경우에만 FCM 토큰을 발급/저장하도록
  하여, 불필요한 알림 권한 요청/저장 방지 및 UX 명확화

### 2. 동작 구조/원리

- 알림 스위치(SwitchToggle)를 처음 ON(활성화)하면 FCM 권한 요청 및 토큰 저장
- 한 번 ON이 되면 OFF(비활성화)로 변경 불가(스위치 비활성화)
- 상태: notificationsEnabled(알림 설정 여부), notificationLocked(한 번 ON되면
  true, 스위치 비활성화)

### 3. 세부 동작 과정

1. 사용자가 설정 페이지 진입
2. 알림 스위치가 OFF 상태
3. 사용자가 스위치 ON → FCM 권한 요청
   - 권한 없음: 권한 요청 → 허용 시 토큰 저장, 거부 시 안내
   - 권한 허용: 토큰 저장, 스위치 비활성화
4. 성공 시 notificationsEnabled, notificationLocked 모두 true
5. 스위치 OFF 불가 (notificationLocked가 true면 비활성화)

### 4. 고려사항/특이사항

- 브라우저에서 알림 권한이 거부된 경우 JS에서 알림을 켤 수 없음
- 안내 메시지는 모달/알림 등으로 제공
- 서버에 FCM 토큰을 등록/삭제하는 방식으로 알림 수신 제어

### 5. 결론/의견

- SwitchToggle로 알림을 켜는 것은 서버에 FCM 토큰을 등록하는 것
- 브라우저 권한이 거부된 경우에는 JS에서 알림을 켤 수 없음
- UX를 명확하게 하여 사용자가 의도적으로 알림을 켜는 경우에만 동작하도록 개선

---

## [PWA와 웹 환경 동기화 문제]

- PWA(모바일 설치 앱)와 웹(브라우저)에서 로그인, 알림, 토큰 등이 따로 놀고 동기
  화가 안 되는 현상

### 1. 동작 목적/배경

- 사용자가 PWA로 설치해서 쓰든, 웹에서 접속하든 **동일한 사용자 경험**(로그인,
  알림, 데이터 등)을 제공하고 싶음
- 로그인 상태, 알림(FCM), 토큰 등이 **환경에 따라 분리**되어 불편함 발생

### 2. 동작 구조/원리

- PWA와 웹은 **같은 서비스워커, 같은 도메인, 같은 저장소**를 사용할 때만 상태가
  동기화됨
- 서비스워커가 다르거나, 도메인이 다르거나, 저장소(로컬스토리지 등)가 분리되면
  각각 따로 동작
- FCM(알림) 토큰, 로그인 토큰 등은 **환경별로 따로 관리**될 수 있음

### 3. 세부 동작 과정

1. 서비스워커 파일이 여러 개이거나, 등록 경로가 다르면 각각 따로 동작
2. PWA와 웹이 서로 다른 도메인/포트/프로토콜에서 실행되면 저장소가 분리됨
3. 토큰을 localStorage에만 저장하면 서비스워커와 동기화가 안 됨
4. FCM 토큰이 환경별로 다르게 관리되어 알림이 한쪽에서만 오거나, 토큰이 갱신될
   때마다 로그인이 풀릴 수 있음

### 4. 고려사항/특이사항

- 서비스워커는 반드시 **하나의 파일**로 통일해서 `/` 경로에 등록해야 함
- PWA 설치 및 웹 접속 모두 **동일한 도메인/프로토콜/포트**에서 이루어져야 함
- 토큰 등 중요한 데이터는 **IndexedDB** 등 공유 가능한 저장소를 쓰거나, 서비스워
  커와 main thread 간에 **postMessage**로 동기화 필요
- FCM 토큰 갱신 시 서버에 항상 최신 토큰을 등록해야 함

### 5. 결론/의견

- **서비스워커 파일 통일, 도메인 일치, 토큰 동기화**가 핵심
- 위 세 가지가 맞지 않으면 PWA와 웹이 완전히 분리되어 동작할 수밖에 없음
- 구조를 점검하고, 필요한 부분은 코드/설정 수정이 필요
